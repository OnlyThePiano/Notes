# TCP:传输控制协议



## TCP 三次握手

**- TCP头的字段：**

* 序号 (Seq)
* 确认 (ACK)
* 确认号 (ack)
* 同步 (SYN)



**- 确认号和序号：**

确认号占 4 字节，序号占 2 个字节；确认号是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是501，而数据长度是 200 字节 (序号501 ~ 700) ， 这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此， B 期望收到 A的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。



**- 确认号和确认：**

ACK 被设置为 1 表示确认号字段是有效的；如果 ACK 为 0，则该段不包含确认信息，即确认号字段可以忽略。

---



![image-20200723103319865](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200723103319865.png)

一开始，B 的 TCP 服务器进程先创建 `传输控制块TCB` ，准备接受客户进程的连接请
求。然后服务器进程就处于 `LISTEN` (收听)状态，等待客户的连接请求。如有，即作出响应。

(1) A 的 TCP 客户进程也是首先创建 `传输控制模块TCB` 。然后，在打算建立 TCP 连接时，
向 B 发出连接请求报文段，这时首部中的同步位 SYN = 1，同时选择一个 初始序号 seq  = x。这时，TCP 客户进程进入 `SYN-SENT`  (同步已发送) 状态。

(2) B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号 ack = x + 1，初始序号 seq = y。这时 TCP 服务器进程进入 `SYN-RCVD`  (同步收到) 状态。



(3) TCP 客户进程收到 B 的确认后，还要向 B 给出确认。将确认报文段的 ACK 位置 1 ，确认号 ack = y + 1，序号 seq = x + 1。这时 TCP 连接已经建立，A 进入 `ESTABLISHED`  (已建立连接) 状态。当 B 收到 A 的确认后，也进入 `ESTABLISHED` 状态。



**第 2 次握手传回了 ACK，为什么还要传回 SYN ？**

回传 SYN 是为了建立并确认从服务端到客户端的通信。而每发送一个 SYN，序列号就会自动+1。

> SYN 同步序列号 (Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 报文段，服务器使用 SYN-ACK 报文段应答表示接收到了这个报文段，如果丢失，该 SYN 段就会重传；最后客户机再以 ACK(Acknowledgement）报文段响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

> SYN 报文段：一个在 TCP 头部的 SYN 位字段置位的 TCP/IP 数据包。客户端和服务器利用 SYN 报文段交换彼此的初始序列号。



**为什么TCP客户端最后还要发送一次确认呢 ？**

主要防止已经失效的连接请求报文突然又传送到了服务器，导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。



## TCP 四次挥手

![image-20200724233639331](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200724233639331.png)



(1) A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq=u (等于前面已传送过的数据的最后一个字节的序号加1) ；这时 A 进入 `FIN-WAIT-1` (终止等待1) 状态，等待 B 的确认。

(2) B 收到连接释放报文段后即发出确认，确认号是 ack=u+ 1，序号是 v (等于 B 前面已传送过的数据的最后一个字节的序号加1) 。然后 B 就进入 `CLOSE-WAIT ` (关闭等待) 状态。A 收到来自 B 的确认后，就进入 `FIN-WAIT-2`  (终止等待2) 状态，等待 B 发出的连接释放报文段。

TCP 服务器进程这时应通知高层应用进程，因而从 A->B 的连接就释放了，这时的 TCP 连接处于 `半关闭` (half-close) 状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B->A 这个方向的连接并未关闭，这个状态可能会持续一段时间。

(3) 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连
接释放报文段必须使 FIN=1，确认位 ACK 置 1，确认号 ack=u+1，序号为 w。这时 B 就进入 `LAST-ACK` (最后确认) 状态，等待 A 的确认。

(4) A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack=w+ 1 ，序号是seq=u+ 1 (根据TCP标准，前面发送过的FIN报文段要消耗一个序号) 。然后进入到 `IME-WAIT` (时间等待) 状态。

**注意：** 现在 TCP 连接还没有释放掉。必须经过时间等 `待计时器 (TIME-WAIT timer)`   设置的时间  `2MSL`  后，A 才进入到 `CLOSED` 状态。



**为什么客户端最后还要等待 2MSL ？**

* MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

* 保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来：“我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到”；于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。
* 防止类似与 “三次握手” 中提到了的 “已经失效的连接请求报文段” 出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
