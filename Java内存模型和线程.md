## 目录

- [Java 内存模型和线程](#java--------)
  * [一、Java 内存模型](#--java-----)
    + [1. 主内存和工作内存](#1---------)
    + [2. 内存间的交互](#2-------)
    + [2. volatile 关键字](#2-volatile----)
    + [3. 并发编程的三个重要特性](#3------------)
    + [4. volatile 、 synchronized  和 final](#4-volatile---synchronized----final)
  * [二、线程](#----)

# Java 内存模型和线程

## 一、Java 内存模型

`Java 内存模型` 和 `Java 内存区域` 是不一样的东西，内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分。

而内存模型（Java Memory Model，简称 JMM ）是定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式，如果我们要想深入了解Java并发编程，就要先理解好 Java 内存模型。

**（1）Java 内存区域**

![image-20200720175903513](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200720175903513.png)



**（2）物理机器内存模式**

![image-20200720180353374](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200720180353374.png)

**（3）Java 内存模型**

![image-20200720191154331](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200720191154331.png)



不同架构的物理机器可以拥有不一样的内存模型，而 Java虚拟机也有自己的内存模型，Java 虚拟机规范中试图定义一种Java内存模型 (Java Memory Model, JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。



### 1. 主内存和工作内存

Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量（**线程共享的变量**）`存储到内存` 和 `从内存中取出变量` 这样底层细节。

**- Java 内存模型中的变量：**

* 实例字段
* 静态字段
* 构成数组对象的元素



Java 内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。

这里的工作内存是 JMM 的一个抽象概念，也叫本地内存，其存储了该线程以读 / 写共享变量的副本。**就像每个处理器内核拥有私有的高速缓存，JMM 中每个线程拥有私有的本地内存。**



### 2. 内存间的交互

不同线程之间无法直接访问对方工作内存中的变量，线程间的通信一般有两种方式进行：

1. 通过消息传递
2. 共享内存

Java 线程间的通信采用的是共享内存方式，线程、主内存和工作内存的交互关系如下图所示：



![image-20200720190342368](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200720190342368.png)

**知道了线程、主内存和工作内存的交互关系，那 Java 内存模型是如何实现的呢 ？**

Java 内存模型中定义了以下 8 种操作来完成：`lock` 、 `unlock` 、 `read` 、`load` 、 `asign` 、`store` 、`write`  。



### 2. volatile 关键字

看上面的内存交互关系图可以知道，线程可以把变量保存 **本地内存** 中，而不是直接在 **主存** 中进行读写。无论是 `普通变量` 还是 `volatile变量` 都是如此，普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说 **voltile** 保证了多线程操作时变量的 `可见性` ，而普通变量则不能保证这一点。

**volatile** 关键字还有一个作用是防止指令重排序（`有序性`）。Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。

**注意：** volatile 并不是线程安全的

`volatile` 虽然保证了可见性，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。而 `synchronized` 关键字则是由 “一个变量在同一个时刻只允许一条线程对其进行 lock 操作” 这条规则获得线程安全的。



### 3. 并发编程的三个重要特性

* **原子性：**

  一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。`synchronized `可以保证代码片段的原子性。

* **可见性 ：**

  当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 、 `synchronized` 、 `final` 关键字可以保证共享变量的可见性。

* **有序性：**

  代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile`  关键字可以禁止指令进行重排序优化；`synchronized` 则有“一个变量在同一时刻只能一条线程对其进行 lock 操作” 获得。

**- final 的可见性：**

final 关键字的可见性是指：被 final 修饰的字段在构造器中一且初始化完成，并且构造器没有把 “this" 的引用传递出去(  `this 引用逃逸` 是一件很危险的事情，其他线程有可能通过这个引用访问到 “初始化了一半” 的对象)，那在其他线程中就能看见 final 字段的值。

如下，变量 i, j 都具备了可见性，它们无需同步就能够被其他线程正确访问。

~~~java
public class testFinal {
	public static final int i;
    public final int j;
    
    public testFinal()
    {
        i = 0;
        j = 0;
    }
}
~~~



### 4. volatile 、 synchronized  和 final

- `volatile` 是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好。但是 volatile关 键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。`synchronized` 关键字在 JavaSE1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。
- 多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字可能会发生阻塞。
- volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。
- volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。



## 二、线程

[线程]()