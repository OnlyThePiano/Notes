## 目录

- [TCP:传输控制协议](#tcp-------)
  * [一、TCP 三次握手](#--tcp-----)
  * [二、TCP 四次挥手](#--tcp-----)
  * [三、TCP 协议如何保证可靠传输](#--tcp-----------)
    + [1. ARQ 协议 (Automatic Repeat-reQuest)](#1-arq-----automatic-repeat-request-)
    + [2. 滑动窗口和流量控制](#2----------)
    + [3. 拥塞控制](#3-----)
- [UDP：用户数据报协议](#udp--------)
- [TCP 和 UDP 协议的应用](#tcp---udp------)



# TCP:传输控制协议

**TCP 最主要的特点：**

1. 面向连接的运输层协议
2. 每一条 TCP 连接只能用两个 `端点`
3. TCP 提供可靠交付的服务
4. TCP 提供全双工通信
5. 面向 `字节流`

> TCP 中的 “流" (stream) 指的是流入到进程或从进程流出的字节序列。“面向字节流” 的含义是：虽然应用程序和 TCP 的交互是一次一个数据块(大小不等)，但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。



**TCP 报文段的首部格式如下图：**

![image-20200726112145504](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200726112145504.png)

## 一、TCP 三次握手

**- TCP头的字段：**

* 序号 (Seq)
* 确认 (ACK)
* 确认号 (ack)
* 同步 (SYN)



**- 确认号和序号：**

确认号占 4 字节，序号占 2 个字节；确认号是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是501，而数据长度是 200 字节 (序号501 ~ 700) ， 这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此， B 期望收到 A的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。



**- 确认号和确认：**

ACK 被设置为 1 表示确认号字段是有效的；如果 ACK 为 0，则该段不包含确认信息，即确认号字段可以忽略。

---



![image-20200723103319865](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200723103319865.png)

一开始，B 的 TCP 服务器进程先创建 `传输控制块TCB` ，准备接受客户进程的连接请
求。然后服务器进程就处于 `LISTEN` (收听)状态，等待客户的连接请求。如有，即作出响应。

**(1)** A 的 TCP 客户进程也是首先创建 `传输控制模块TCB` 。然后，在打算建立 TCP 连接时，
向 B 发出连接请求报文段，这时首部中的同步位 SYN = 1，同时选择一个 初始序号 seq  = x。这时，TCP 客户进程进入 `SYN-SENT`  (同步已发送) 状态。

**(2)** B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号 ack = x + 1，初始序号 seq = y。这时 TCP 服务器进程进入 `SYN-RCVD`  (同步收到) 状态。



**(3)** TCP 客户进程收到 B 的确认后，还要向 B 给出确认。将确认报文段的 ACK 位置 1 ，确认号 ack = y + 1，序号 seq = x + 1。这时 TCP 连接已经建立，A 进入 `ESTABLISHED`  (已建立连接) 状态。当 B 收到 A 的确认后，也进入 `ESTABLISHED` 状态。



**第 2 次握手传回了 ACK，为什么还要传回 SYN ？**

回传 SYN 是为了建立并确认从服务端到客户端的通信。而每发送一个 SYN，序列号就会自动+1。

> SYN 同步序列号 (Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 报文段，服务器使用 SYN-ACK 报文段应答表示接收到了这个报文段，如果丢失，该 SYN 段就会重传；最后客户机再以 ACK(Acknowledgement）报文段响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

> SYN 报文段：一个在 TCP 头部的 SYN 位字段置位的 TCP/IP 数据包。客户端和服务器利用 SYN 报文段交换彼此的初始序列号。



**为什么TCP客户端最后还要发送一次确认呢 ？**

主要防止已经失效的连接请求报文突然又传送到了服务器，导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。



## 二、TCP 四次挥手

![image-20200724233639331](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200724233639331.png)



**(1)** A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq=u (等于前面已传送过的数据的最后一个字节的序号加1) ；这时 A 进入 `FIN-WAIT-1` (终止等待1) 状态，等待 B 的确认。

**(2)** B 收到连接释放报文段后即发出确认，确认号是 ack=u+ 1，序号是 v (等于 B 前面已传送过的数据的最后一个字节的序号加1) 。然后 B 就进入 `CLOSE-WAIT ` (关闭等待) 状态。A 收到来自 B 的确认后，就进入 `FIN-WAIT-2`  (终止等待2) 状态，等待 B 发出的连接释放报文段。

TCP 服务器进程这时应通知高层应用进程，因而从 A->B 的连接就释放了，这时的 TCP 连接处于 `半关闭` (half-close) 状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B->A 这个方向的连接并未关闭，这个状态可能会持续一段时间。

**(3)** 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连
接释放报文段必须使 FIN=1，确认位 ACK 置 1，确认号 ack=u+1，序号为 w。这时 B 就进入 `LAST-ACK` (最后确认) 状态，等待 A 的确认。

**(4)** A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack=w+ 1 ，序号是seq=u+ 1 (根据TCP标准，前面发送过的FIN报文段要消耗一个序号) 。然后进入到 `IME-WAIT` (时间等待) 状态。

**注意：** 现在 TCP 连接还没有释放掉。必须经过时间等 `待计时器 (TIME-WAIT timer)`   设置的时间  `2MSL`  后，A 才进入到 `CLOSED` 状态。



**为什么客户端最后还要等待 2MSL ？**

* MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

* 保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来：“我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到”；于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。
* 防止类似与 “三次握手” 中提到了的 “已经失效的连接请求报文段” 出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。



## 三、TCP 协议如何保证可靠传输

### 1. ARQ 协议 (Automatic Repeat-reQuest)

自动重传请求，是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。

**(1) 停止等待ARQ协议**

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；

停止等待ARQ协议虽然简单，但是存在的缺点是，信道利用率低，等待时间长。

**(2) 连续ARQ协议**

* 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。



### 2. 滑动窗口和流量控制

**流量控制是为了控制发送方发送速率，保证接收方来得及接收。**

**TCP 利用滑动窗口实现流量控制。**

![image-20200726105931205](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200726105931205.png)

 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 3. 拥塞控制

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。

拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个 `全局性` 的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，`流量控制` 往往是点对点通信量的控制，是个端到端的问题。`流量控制` 所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。



![image-20200726105338296](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200726105338296.png)

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为1，每经过一个传播轮次，cwnd 加倍。
- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
- **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。



# UDP：用户数据报协议

**UDP 最主要的特点：**

1. UDP 是无连接的
2. UDP 使用尽最大来努力交付，即不保证可靠交付
3. UDP 是面向报文的
4. UDP 没有拥塞控制
5. UDP 支持一对多、多对一、多对多的交换通信
6. UDP 头部开销小，只有 8 个字节；而 TCP 头部是 20 个字节

>UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。



**UDP 首部格式如下图：**

![image-20200726112311016](https://github.com/OnlyThePiano/Notes/blob/master/images/image-20200726112311016.png)



# TCP 和 UDP 协议的应用

**UDP**  在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

**TCP** 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。
