## 目录

- [数据结构-树](#------)
  * [一、二叉树](#-----)
    + [1. 二叉树的深度优先遍历](#1-----------)
    + [2. 二叉树的广度优先遍历](#2-----------)
    + [3. 二叉树的应用：哈夫曼树](#3------------)
  * [二、树和森林](#------)
    + [1. 树和森林的遍历](#1--------)
    + [2. 树、森林和二叉树的转换](#2------------)
  * [三、搜索树](#-----)
    + [1. 二叉排序树](#1------)
    + [2. 平衡二叉树](#2------)
    
    

# 数据结构-树

线性表、栈和队列等线性结构的元素之间是一对一的线性关系，对于 “ 书的目录、计算机的系统结构、互联网域名系统等 ” 是一种分层的树形结构的非线性关系。

遍历是树形结构最为重要的操作，通过遍历可以将二叉树的非线性结构转换位线性结构。

## 一、二叉树

**- 特殊的二叉树：**

* 完全二叉树
* 满二叉树

**- 数据结构类型定义：**

* 对于node需要这些属性：`left`  ， `right` 和  `key`。其中 left 和 right 是左右指针，而 key 是储存的数据，这里用泛型。

  ~~~java
  private class Node 
  {
      private T key;
      private Node left;
      private Node right;
      
      
      private Node(T key) {
          this.key = key;
  	    this.left = null;
          this.right = null;
      }
      
      private Node(T key, Node left, Node right) {
          this.data = key;
          this.left = left;
          this.right = right;
      }
      
      //省略set、get方法
  }
  ~~~



**- 二叉树的建立（递归）：**

~~~java
public class BinaryTreeBuilder<T> {
    //树的根节点
    private Node root = null;

    public Node createBinTree(Scanner scanner)
	{
    	T data = scanner.next();
    	if (data == '@')
        	return null;	//空节点
    	else
        	Node node = new Node(data, createBinTree(scanner), createBinTree(scanner));
    
    	return node;
	}
}

~~~



### 1. 二叉树的深度优先遍历

(1) 先序遍历

(2) 中序遍历

(3) 后序遍历



### 2. 二叉树的广度优先遍历



### 3. 二叉树的应用：哈夫曼树

哈夫曼树又称最优二叉树。



## 二、树和森林

### 1. 树和森林的遍历

### 2. 树、森林和二叉树的转换

**- 转换步骤：**

1. 加线
2. 去线
3. 调整



## 三、搜索树

线性结构的查找效率并不理想，因而需要转向更为复杂的数据结构以达到满意的查找效率。

排序后的有序序列可以将时间复杂度降低到 O(log2n)，但这对于动态插入和删除来说，最坏的时间复杂度仍然达到了 O(n)；然而 `搜索树` 的设计在关注静态查询效率的同时，也兼顾到了元素的动态调整,具有 O(log2n) 的插入和删除效率。

**- 搜索树有如下几种：**

1. 二叉排序树
2. 平衡二叉树( AVL树 )
3. 红黑树
4. 多路查找树( B树 )



### 1. 二叉排序树

**- 二叉排序树要具有的性质：**

1. 如果左子树非空，左子树的关键码一定**小于**根节点的关键码；
2. 如果右子树非空，右子树的关键码一定**大于**根节点的关键码；
3. 左右子树仍然是二叉排序树。



**比较器-Comparable 接口：**
此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。实现此接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort）进行自动排序 。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。

~~~java
class Node implements Comparable<Node> {
    
    //省略............
    
    //重写compareTo() 方法
    public int compareTo(Node node)
    {
        if (this.key>node.key) {
            return -1;
        }else if (this.key<node.key) {
            return 1;
        }else {
            return 0;
        }
    }

}
~~~



**查找（递归）：**

~~~java
public class BinaryTreeBuilder<T> {
    //树的根节点
    private Node root = null;
    //省略..........
    (1)
    public boolean SearchBST1(T key)
    {
        if (root == null) {
            return false;
        }
        
        else if (key == root.key) {
            return SearchBST(root.left, key);
        }
        
        else {
            return SearchBST(root.right, key);
        }
        
    }
    
    (2)
    public Node SearchBST2(T key)
    {
        Node p = root;
        while (p != null)
        {
            Node parent = p;
            if (p.key == key) {
                return null;
            }
            if (key < p.key) {
                p = p.left;
            }else {
                p = p.right;
            }
            
        }
        return parent;
    }
}

~~~



**插入：**

~~~java
public class BinaryTreeBuilder<T> {
    //省略..........
    
    //树的根节点
    private Node root = null;
    
    public boolean InsertBST(T key) {
        
        //找到父节点
        Node temp = this.SearchBST2(root, key);
        Node p = new Node(key, null, null);
        if (temp == null) {
            System.out.println("exit this key");
        }
        
        if (key < p.key) {
            temp.left = p;
        }else {
            temp.right = p;
        }
 
    }
    
    
}
~~~



**判断是否为空：**

~~~java
public boolean isEmpty()
{
    if (root == null)
        return true;
    else
        return false;
}
~~~



**总结**

给定值的比较次数等于给定值节点在二叉排序树中的层数。如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log2n+1,其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。



### 2. 平衡二叉树

