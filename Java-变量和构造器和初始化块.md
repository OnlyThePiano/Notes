## 目录

- [一、成员变量](#------)
- [二、局部变量](#------)
- [三、构造器](#-----)
- [四、初始化块](#------)

## 一、成员变量

**- 成员变量及其在内存中的运行机制：**

~~~java
class Person
{
    public String name;
    public static int eyeNum;
    
    public static void main()
    {
        Person p1 = new Person();
        Person p2 = new Person();
        
        p1.name = "张三";
        p2.name = "孙悟空";
        p1.eyeNum = 2;
    }
}

~~~

当程序执行第一行代码 `Person p1 = new Person()；` 时，如果这行代码是第一次使用 Person 类,则系统通常会在第一次使用 Person 类时加载这个类，并初始化这个类。在类的准备阶段，系统将会为该类的类变量分配内存空间，并指定默认初始值。

## 二、局部变量

**- 局部变量及其在内存中的运行机制：**

局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化。这意味着定义局部变量后，系统并未为这个变量分配内存空间，直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存到这块内存中。

**-局部变量与成员变量的区别：**

* 与成员变量不同，局部变量不属于任何类或实例，因此它总是保存在其所在方法的栈内存中。

  

* 如果局部变量是基本类型的变量，则直接把这个变量的值保存在该变量对应的内存中；

  

* 如果局部变量是一个引用类型的变量，则这个变量里存放的是地址，通过该地址引用到该变量实际引用的对象或数组。



**注意：** 局部变量的时间周期

栈内存中的变量无须系统垃圾回收，往往随方法或代码块的运行结束而结束。即使在程序中使用局部变量,也应该尽可能地缩小局部变量的作用范围,局部变量的作用范围越小，它在内存里停留的时间就越短，程序运行性能就越好。**因此，能用代码块局部变量的地方，就坚决不要使用方法局部变量。**





## 三、构造器

**- 构造器完全负责对象的创建吗？**

答:不是！构造器是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回了该类的对象，但这个对象并不是完全由构造器负责创建的。

实际上，当调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生了；这些操作在构造器执行之前就都完成了。也就说，当系统开始执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在该构造器中通过 this 来引用。当构造器的执行体执行结束后，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象。



**- 构造器的访问权限**

因为构造器主要用于被其他方法调用，用以返回该类的实例，因而通常把构造器设置成 public 访问权限，从而允许系统中任何位置的类来创建该类的对象。除非在一些极端的情况下，业务需要限制创建该类的对象，可以把构造器设置成其他访问权限。

例如：

* 设置为protected, 主要用于被其子类调用；

  

* 设置为private，阻止其他类创建该类的实例。



## 四、初始化块

* 当创建 java 对象时，系统总是先调用该类里定义的初始化块
* 初始化块旨在创建 Java 对象时隐式执行