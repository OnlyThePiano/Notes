## 目录

- [封装](#--)
  * [访问修饰符](#-----)
- [继承](#--)
  * [重载和重写](#-----)
  * [super 关键字](#super----)
  * [假完全覆盖](#-----)
  * [变量覆盖](#----)
  * [super 和 this](#super---this)
- [多态](#--)
  * [向上转型](#----)
  * [instanceof 运算符（向下转型）](#instanceof----------)

# 封装

**- 什么是封装 ？**

`封装 (Encapsulation)` 是面向对象的三大特征之一,它指的是将对象的状态信息隐藏在对象内部,不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。

如：Java 的核心类都放在java包以及其子包下，Java 扩展的许多类都放在 javax 包以及其子包下。

---



## 访问修饰符

在通常情况下，如果使用 protected 来修饰一个方法， 通常是希望其子类来重写这个方法。

![image-20200519142038416](C:\Users\79949\Desktop\images\image-20200519142038416.png)



# 继承

**- 什么是继承 ？**

继承是面向对象的三大特征之一，也是实现软件复用的重要手段。如果定义一个 Java 类时并未显式指定这个类的直接父类，则这个类默认扩展 java.lang.Object 类。

---

从父辈那里获得一笔财 富称为继承)具有很好的类似性。值得指出的是，Java  的子类不能获得父类的构造器。

**注意：** 覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个 是实例方法。

**- 两同两小一大规则：**

* “两同”即方法名相同、形参列表相同；
* “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
* “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

错误示范，发生编译错误：

![image-20200623103415938](C:\Users\79949\Desktop\images\image-20200623103415938.png)





## 重载和重写

方法重载和方法重写在英语中分别是 overload 和 override ，重载主要发生在同一个类的多个同名方法之间，重写发生在子类和父类的同名方法之间。它们之间的联系很少，除了二者都是发生在方法之间，并要求方法名相同之外，没有太大的相似之处。

当然，父类方法和子类方法之间也可能发生重载,因为子类会获得父类方法，如果子类定义了一个与父类方法有相同的方法名,但参数列表不同的方法，就会形成父类方法和子类方法的重载。

**注意：** final修饰的方法不可被重写，如果出于某些原因，不希望子类重写父类的某个方法，则可以使用final修饰该方法。



## super 关键字

super 是 Java 提供的一个关键字，super 用于限定该对象调用它从父类继承得到的实例变量或方法。

如果在构造器中使用 super，则 super 用于限定该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变量。

static 修饰的方法是属于类的，该方法的调用者可能是一个类，而不是对象，因而super限定也就失去了意义。





## 假完全覆盖

当程序创建一个子类对象时，系统不仅会为该类中定义的实例变量分配内存,也会为它从父类继承得到的所有实例变量分配内存，即使子类定义了与父类中同名的实例变量。也就是说，当系统创建一个Java对象时，如果该Java类有两个父类(一个直接父类A,一个间接父类B)，假设A类中定义了2个实例变量，B类中定义了3个实例变量，当前类中定义了2个实例变量，那么这个Java对象将会保存2+3+2个实例变量。



## 变量覆盖

**如果在子类里定义了与父类中已有变量同名的变量，那么子类中定义的变量会隐藏父类中定义的变量。**注意不是完全覆盖，因此系统在创建子类对象时，依然会为父类中定义的、被隐藏的变量分配内存空间。

**特殊情况：**

private 的范围是同一个类中。

![image-20200519143917612](C:\Users\79949\Desktop\images\image-20200519143917612.png)



## super 和 this 

在一个构造器中调用另一个重载的构造器使用this调用来完成，在子类构造器中调用父类构造器使用super调用来完成。



![image-20200519144243570](C:\Users\79949\Desktop\images\image-20200519144243570.png)

使用super调用和使用this 调用也很像，区别在于super调用的是其父类的构造器，而this调用的是同一个类中重载的构造器。因此，使用super调用父类构造器也必须出现在子类构造器执行体的第一行， 所以this调用和super调用不会同时出现。

从上面运行过程来看，创建任何对象总是从该类所在继承树最项层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器。如果某个父类通过this 调用了同类中重载的构造器，就会依次执
行此父类的多个构造器。



![image-20200519144422237](C:\Users\79949\Desktop\images\image-20200519144422237.png)





# 多态

**- 什么是多态 ？**

编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的 `多态 ( Polymorphism)`。

---

**- Java引用变量有两个类型：**

* 编译时类型，

* 运行时类型。



## 向上转型

因为子类其实是一种特殊的父类， 因此 Java 允许把一个 子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型( upcasting)，向上转型由系统自动完成。（小=大）

~~~java
class BaseClass {
    public void test(){}
}

class SubClass extends BaseClass {
    public void test(){}
    public void sub(){}
    
    public static void main(){
        BaseClass b = new SubClass();
        
        //编译时会报错，因为编译时类型是父类BaseClass，而该类没有sub()方法
        //b.sub();
        
    }
}


~~~

**- 解释一波：**

* 它的编译时类型是父类BaseClass，而运行时类型是子类SubClass
* 当调用该引用变量的test()方法 BaseClass类中定义了该方法，子类SubClass覆盖了父类的该方法时，实际运行时执行的是子类SubClass类中覆盖后的test(）方法，这就可能出现多态了。



引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法。因此，编写 Java 代码时，引用变量只能调用声明该变量时所用类里包含的方法。

~~~java
Object p = new Person()
    
//代码定义一个变量p,则这个p只能调用Object类的方法，而不能调用Person类里定义的方法。
~~~



编写 Java 程序时，引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法，即使它实际所引用的对象确实包含该方法。如果需要让这个引用变量调用它运行时类型的方法，则必须把它强制类型转换成运行时类型，强制类型转换需要借助于类型转换运算符。



**这种强制类型转换不是万能的，转换时需要注意：**

* 基本类型之间的转换只能在数值类型之间进行，这里所说的数值类型包括整数型、字符型和浮点型。但数值类型和布尔类型之间不能进行类型转换。

![image-20200519153301166](C:\Users\79949\Desktop\images\image-20200519153301166.png)

~~~Java

int a = 6;
//int 自动转换为float
float f = a;
//强制类型转换（小=大）
long L = long(f)
~~~





* 引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果是两个没有任何继承关系的类型，则无法进行类型转换，否则编译时就会出现错误。如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类实例才行**(即编译时类型为父类类型，而运行时类型是子类类型)，否则将在运行时引发ClassCastException异常。**

![image-20200519144422237](C:\Users\79949\Desktop\images\image-20200519144422237.png)

~~~java
Object obj = "hello";
//obj变量的编译时类型为Object,运行时实际类型为String
//Object 与String存在继承关系，可以强制类型转换
String s = (String)obj

Object obj2 = new Integer(5);
//obj变量的编译时类型为Object,运行时实际类型为Integer
//Object 与String存在继承关系，可以强制类型转换

//运行报错，因为obj2运行时类型为Integer，而非String
String s2 = (String)obj2

~~~



## instanceof 运算符（向下转型）

instanceof 和 (type) 是Java提供的两个相关的运算符，通常先用 instanceof 判断一个对象是否可以强制类型转换，然后再使用 (type) 运算符进行强制类型转换，从而保证程序不会出现错误。

instanceof 运算符的前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类( 也可以是接口，可以把接口理解成一种特殊的类)， 它用于判断前面的对象是否是后面的类，或者其子类、实现类的实例。如果是，则返回true,否则返回false。



**注意：**  instanceof 运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系，否则会引起编译错误。