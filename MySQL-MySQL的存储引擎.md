# MVCC 多版本并发控制

**MVCC** (Multiversion concurrency control)，多版本并发控制，提供并发访问数据库时，对事务内读取的到的内存做处理，用来避免写操作堵塞读操作的并发问题。

下面例子解释：

程序员 A 正在读数据库中某些内容，而程序员 B 正在给这些内容做修改（假设是在一个事务内修改，大概持续 10s 左右），A 在这 10s 内则可能看到一个不一致的数据，在 B 没有提交前，如何让 A 能够一直读到的数据都是一致的呢 ？

**第一种方法： 基于锁的并发控制** ，程序员 B 开始修改数据时，给这些数据加上锁，程序员 A 这时再读，就发现读取不了，处于等待情况，只能等 B 操作完才能读数据，这保证 A 不会读到一个不一致的数据，但是这个会影响程序的运行效率。

**第二种方法：MVCC** ，每个用户连接数据库时，看到的都是某一特定时刻的数据库快照，在 B 的事务没有提交之前，A 始终读到的是某一特定时刻的数据库快照，不会读到 B 事务中的数据修改情况，直到 B 事务提交，才会读取 B 的修改内容。

所以呢，一个支持 MVCC 的数据库，在更新某些数据时，并非使用新数据覆盖旧数据，而是标记旧数据是过时的，同时在其他地方新增一个数据版本。因此，同一份数据有多个版本存储，但只有一个是最新的。



**那怎么实现去实现 MVCC 呢 ？**

答：MVCC 有两种实现方式；第一种实现方式是将数据记录的多个版本保存在数据库中，当这些不同版本数据不再需要时，垃圾收集器回收这些记录。这个方式被`PostgreSQL` 和 `Firebird/Interbase` 采用; `SQL Server` 使用的类似机制，不同的是旧版本数据不是保存在数据库中，而保存在不同于主数据库的另外一个数据库tempdb 中。第二种实现方式只在数据库保存最新版本的数据，但是会在使用 `undo` 时动态重构旧版本数据，这种方式被 `Oracle `和 `MySQL/InnoDB` 使用。



MVCC 提供了时间一致性的处理思路，在MVCC下读事务时，通常使用一个 **时间戳** 或者 **事务ID** 来确定访问哪个状态的数据库及哪些版本的数据。`读事务` 跟 `写事务` 彼此是隔离开来的，彼此之间不会影响。假设同一份数据，既有读事务访问，又有写事务操作，实际上，写事务会新建一个新的数据版本，而读事务访问的是旧的数据版本，直到写事务提交，读事务才会访问到这个新的数据版本。



# MySQL 的存储引擎

## 一、InnoDB 存储引擎

**InnoDB** 是 MySQL 的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期 (short-lived) 事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB 的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。

InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是
REPEATABLE READ (可重复读) ，并且通过 **间隙锁** (next-key locking) 策略防止 **幻读** 的出现。间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

**间隙锁是怎样去防止幻读的呢 ？** 



**InnoDB表** 是基于 **聚簇索引** 建立的，InnoDB 的索引结构和 MySQL 的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的 **二级索引** (secondary index,非主键索引) 中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。

作为事务型的存储引擎，InnoDB 通过一些机制和工具支持真正的 **热备份** ，而MySQL 的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。



## 二、MyISAM 存储引擎

在 MySQL 5.1及之前的版本，MyISAM 是默认的存储引擎。MyISAM 提供了大量的特
性，包括全文索引、压缩、空间函数(GIS) 等，但 MyISAM 不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。对于只读的数据，或者表比较小、可以忍受修复(repair) 操作，则依然可以继续使用 MyISAM 。



**- MyISAM 特性：**

1. **加锁与并发**

   是对整张表加锁，而不是针对行。读取时会对需要读到的所有表加 `共享锁` ，写入时则对表加 `排他锁` 。但是在表有读取查询的同时，也可以往表中插入新的记录。

2. **修复**

   对于 MyISAM 表，MySQL 可以手工或者自动执行检查和修复操作，但这里说的修复和事务恢复以及崩溃恢复是不同的概念。执行表的修复可能导致一些数据丢失，而且修复操作是非常慢的。

3. **索引特性**

   对于 MyISAM 表，即使是 `BLOB` 和 `TEXT` 等长字段，也可以基于其前 500 个字符创建索引；MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。



**MyISAM 性能**
MyISAM引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。MyISAM 最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处于 **"Locked”** 状态，那么毫无疑问表锁就是罪魁祸首。



## 三、其它存储引擎

* Archive 引擎
* Blackhole 引擎
* CSV 引擎
* Federated 引擎
* Memory 引擎
* Merge 引擎

